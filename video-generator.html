<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&family=Noto+Sans+Tamil:wght@400;700&family=Noto+Sans+Devanagari:wght@400;700&family=Inter:wght@400;700&family=Roboto:wght@400;700&display=swap"
        rel="stylesheet">
    <title>Slide Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin-bottom: 30px;
            color: #333;
        }

        .section {
            margin-bottom: 25px;
        }

        label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #555;
        }

        input[type="file"],
        input[type="text"],
        input[type="number"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 100%;
            margin-bottom: 10px;
        }

        select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 100%;
            margin-bottom: 10px;
        }

        input[type="color"] {
            padding: 5px;
            cursor: pointer;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .file-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .file-input-group {
            flex: 1;
        }

        .file-inputs label {
            margin-bottom: 5px;
            font-size: 13px;
        }

        .file-inputs input {
            margin-bottom: 0;
        }

        .color-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .color-item {
            display: flex;
            flex-direction: column;
        }

        .color-item label {
            margin-bottom: 5px;
            font-weight: normal;
            font-size: 13px;
        }

        .color-item input {
            width: 100%;
        }

        button {
            background: #4CAF50;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .preview-controls {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .preview-controls button {
            padding: 10px 20px;
        }

        .preview-controls input {
            margin: 0;
        }

        .preview-controls label {
            margin: 0;
            font-weight: normal;
            font-size: 14px;
        }

        .progress {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .info {
            background: #e3f2fd;
            padding: 15px;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #1976D2;
        }

        .error {
            background: #ffebee;
            padding: 15px;
            border-left: 4px solid #f44336;
            border-radius: 4px;
            margin-top: 15px;
            color: #c62828;
            display: none;
        }

        .success {
            background: #e8f5e9;
            padding: 15px;
            border-left: 4px solid #4CAF50;
            border-radius: 4px;
            margin-top: 15px;
            color: #2e7d32;
            display: none;
        }

        .bg-image-note {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .preview {
            display: none;
            margin-top: 20px;
            border: 2px solid #2196F3;
            border-radius: 8px;
            overflow: hidden;
        }

        #previewCanvas {
            width: 100%;
            height: auto;
            display: block;
            background: white;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ðŸ“Š Slide Generator</h1>

        <div class="info">
            <strong>How to use:</strong> Upload 1-2 TXT files and preview slides before generating a ZIP file with all
            slide variations. Optionally add an Audacity label file to generate FFmpeg concat instructions.
            <br><strong>Stanza Detection:</strong> 4-line stanzas separated by blank lines will have lines 2 & 4
            indented.
        </div>

        <div class="section">
            <label>Upload Text Files:</label>
            <div class="file-inputs">
                <div class="file-input-group">
                    <label>File 1 (Required)</label>
                    <input type="file" id="file1" accept=".txt" required>
                </div>
                <div class="file-input-group">
                    <label>File 2 (Optional - for 2nd language)</label>
                    <input type="file" id="file2" accept=".txt">
                </div>
            </div>
        </div>

        <div class="section">
            <label>Audacity Label File (Optional):</label>
            <input type="file" id="labelFile" accept=".txt">
            <p class="bg-image-note">Upload an Audacity label file to generate FFmpeg concat.txt with durations</p>
        </div>

        <div class="section">
            <label>Background Image (Optional):</label>
            <input type="file" id="bgImage" accept=".png,.jpg,.jpeg">
            <p class="bg-image-note">Upload a PNG or JPG to use as background for all slides (instead of solid color)
            </p>
        </div>

        <div class="section">
            <label>Custom Start Slide (Optional):</label>
            <input type="file" id="startSlide" accept=".png,.jpg,.jpeg">
            <p class="bg-image-note">Upload a custom start slide (1920x1080 recommended)</p>
        </div>

        <div class="section">
            <label>Custom End Slide (Optional):</label>
            <input type="file" id="endSlide" accept=".png,.jpg,.jpeg">
            <p class="bg-image-note">Upload a custom end slide (1920x1080 recommended)</p>
        </div>

        <div class="section">
            <label for="skipLines">Skip First N Lines from Source:</label>
            <input type="number" id="skipLines" value="0" min="1" max="1000">
        </div>

        <div class="section">
            <label for="skipLastLines">Skip Last N Lines from Source:</label>
            <input type="number" id="skipLastLines" value="0" min="1" max="1000">
        </div>

        <div class="section">
            <label>Canto & Chapter Information:</label>
            <div class="file-inputs">
                <div class="file-input-group">
                    <label>Canto Number</label>
                    <input type="number" id="cantoNumber" min="1" max="12" placeholder="e.g., 1">
                </div>
                <div class="file-input-group">
                    <label>Chapter Number</label>
                    <input type="number" id="chapterNumber" min="1" max="100" placeholder="e.g., 5">
                </div>
            </div>
            <div class="file-inputs">
                <div class="file-input-group">
                    <label>Canto Name</label>
                    <input type="text" id="cantoName" placeholder="Canto Name (e.g., Creation)"
                        style="margin-bottom: 10px;">
                </div>
                <div class="file-input-group">
                    <label>Chapter Name</label>
                    <input type="text" id="chapterName"
                        placeholder="Chapter Name (e.g., The Activities of Maharaja Prthu)"
                        style="margin-bottom: 10px;">
                </div>
            </div>

            <div class="section">
                <label>Chapter Image (for first slide):</label>
                <input type="file" id="chapterImage" accept=".png,.jpg,.jpeg">
                <p class="bg-image-note">Upload an image for the first slide (will be displayed in 1:1.15 ratio)</p>
            </div>

            <div class="section">
                <label>Profile Image (for first slide):</label>
                <input type="file" id="profileImage" accept=".png,.jpg,.jpeg" value="images/profileW.png">
                <p class="bg-image-note">Upload an image for the first slide (will be displayed in 1:1 ratio)</p>
            </div>

            <div class="section">
                <label for="linesPerSlide">Lines per Slide:</label>
                <input type="number" id="linesPerSlide" value="8" min="1" max="20">
            </div>

            <div class="section">
                <label for="topMargin">Top Margin (pixels):</label>
                <input type="number" id="topMargin" value="70" min="0" max="500">
            </div>

            <div class="section">
                <label for="leftMargin">Left Margin (pixels):</label>
                <input type="number" id="leftMargin" value="120" min="0" max="500">
            </div>

            <div class="section">
                <label for="fontFamily">Font Family:</label>
                <select id="fontFamily">
                    <option value="Noto Sans Tamil">Noto Sans Tamil (Tamil)</option>
                    <option value="Noto Sans Devanagari">Noto Sans Devanagari (Sanskrit)</option>
                    <option value="Inter">Inter (English)</option>
                    <option value="Roboto">Roboto (English)</option>
                    <option value="Noto Sans">Noto Sans (English)</option>
                    <option value="Arial">Arial (System)</option>
                    <option value="Helvetica">Helvetica (System)</option>
                    <option value="Times New Roman">Times New Roman (System)</option>
                    <option value="Courier New">Courier New (System)</option>
                    <option value="Georgia">Georgia (System)</option>
                    <option value="Verdana">Verdana (System)</option>
                </select>
            </div>

            <div class="section">
                <label for="baseFontSize">Base Font Size (will auto-adjust if needed):</label>
                <input type="number" id="baseFontSize" value="60" min="10" max="150">
            </div>

            <div class="section">
                <label for="lineHeightMultiplier">Line Height Multiplier:</label>
                <input type="number" id="lineHeightMultiplier" value="2" min="0.8" max="3" step="0.1">
            </div>

            <div class="section">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <input type="checkbox" id="preserveBlankLines">
                    <label for="preserveBlankLines" style="margin: 0; font-weight: bold; color: #555;">Preserve Blank
                        Lines</label>
                </div>
                <p class="bg-image-note">Keep blank lines as-is in slides (counts towards lines per slide). Lines with
                    just
                    spaces are always preserved for visual gaps.</p>
            </div>

            <div class="section">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <input type="checkbox" id="enableIndent" checked>
                    <label for="enableIndent" style="margin: 0; font-weight: bold; color: #555;">Enable Indent for Lines
                        2 &
                        4</label>
                </div>
                <p class="bg-image-note">Add indentation to 2nd and 4th lines of detected 4-line stanzas</p>
            </div>

            <div class="section">
                <label for="bgColor">Background Color:</label>
                <input type="color" id="bgColor" value="#ffffff">
            </div>

            <div class="section">
                <label>Text Colors:</label>
                <div class="color-grid">
                    <div class="color-item">
                        <label>Before (Dim):</label>
                        <input type="color" id="colorBefore" value="#999999">
                    </div>
                    <div class="color-item">
                        <label>Highlighted:</label>
                        <input type="color" id="colorHighlight" value="#FFFF00">
                    </div>
                    <div class="color-item">
                        <label>After (Normal):</label>
                        <input type="color" id="colorAfter" value="#FFFFFF">
                    </div>
                </div>
            </div>

            <div class="button-group">
                <button type="button" onclick="previewSlide()">Preview Slide</button>
                <button type="button" onclick="generateSlideZip()">Generate Slides ZIP</button>
            </div>

            <div id="preview" class="preview">
                <div class="preview-controls">
                    <button type="button" onclick="previousSlide()">&lt; Previous</button>
                    <div
                        style="text-align: center; display: flex; gap: 10px; align-items: center; justify-content: center;">
                        <label>Slide:</label>
                        <select id="slideSelector" onchange="jumpToSlide()"
                            style="width: auto; min-width: 80px; margin: 0;"></select>
                        <label>| Highlight:</label>
                        <select id="highlightSelector" onchange="jumpToHighlight()"
                            style="width: auto; min-width: 80px; margin: 0;"></select>
                    </div>
                    <button type="button" onclick="nextSlide()">Next &gt;</button>
                </div>
                <canvas id="previewCanvas" width="1920" height="1080"></canvas>
            </div>

            <div class="error" id="error"></div>
            <div class="success" id="success"></div>

            <div class="progress" id="progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script>
            const webFonts = [
                { family: 'Noto Sans', weight: '400' },
                { family: 'Noto Sans', weight: '700' },
                { family: 'Noto Sans Tamil', weight: '400' },
                { family: 'Noto Sans Tamil', weight: '700' },
                { family: 'Noto Sans Devanagari', weight: '400' },
                { family: 'Noto Sans Devanagari', weight: '700' },
                { family: 'Inter', weight: '400' },
                { family: 'Inter', weight: '700' },
                { family: 'Roboto', weight: '400' },
                { family: 'Roboto', weight: '700' }
            ];

            // Pre-load fonts for canvas
            async function loadWebFonts() {
                const promises = webFonts.map(font => {
                    return document.fonts.load(`${font.weight} 12px "${font.family}"`);
                });
                await Promise.all(promises);
                console.log('âœ“ Web fonts loaded for canvas');
            }

            let currentPreviewSlideGroup = 0;
            let currentPreviewHighlight = 0;
            let totalSlideGroups = 0;
            let linesPerSlide = 8;
            let cachedLines1 = [];
            let cachedLines2 = [];
            let cachedBgImage = null;
            let cachedLabelData = null;
            let cachedStartSlide = null;
            let cachedEndSlide = null;
            let labelFileName = null;
            let cachedChapterImage = null;
            let cachedProfileImage = null;
            let cantoNumber = '';
            let chapterNumber = '';
            let cantoName = '';
            let chapterName = '';
            let lastLine = '';

            function saveSettings() {
                const settings = {
                    skipLines: document.getElementById('skipLines').value,
                    skipLastLines: document.getElementById('skipLastLines').value,
                    linesPerSlide: document.getElementById('linesPerSlide').value,
                    topMargin: document.getElementById('topMargin').value,
                    leftMargin: document.getElementById('leftMargin').value,
                    fontFamily: document.getElementById('fontFamily').value,
                    baseFontSize: document.getElementById('baseFontSize').value,
                    lineHeightMultiplier: document.getElementById('lineHeightMultiplier').value,
                    preserveBlankLines: document.getElementById('preserveBlankLines').checked,
                    enableIndent: document.getElementById('enableIndent').checked,
                    bgColor: document.getElementById('bgColor').value,
                    colorBefore: document.getElementById('colorBefore').value,
                    colorHighlight: document.getElementById('colorHighlight').value,
                    colorAfter: document.getElementById('colorAfter').value,
                    cantoNumber: document.getElementById('cantoNumber').value,
                    chapterNumber: document.getElementById('chapterNumber').value,
                    cantoName: document.getElementById('cantoName').value,
                    chapterName: document.getElementById('chapterName').value,
                };
                localStorage.setItem('slideGeneratorSettings', JSON.stringify(settings));
            }

            function loadSavedSettings() {
                const saved = localStorage.getItem('slideGeneratorSettings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        if (settings.skipLines !== undefined) document.getElementById('skipLines').value = settings.skipLines;
                        if (settings.skipLastLines !== undefined) document.getElementById('skipLastLines').value = settings.skipLastLines;
                        if (settings.linesPerSlide !== undefined) document.getElementById('linesPerSlide').value = settings.linesPerSlide;
                        if (settings.topMargin !== undefined) document.getElementById('topMargin').value = settings.topMargin;
                        if (settings.leftMargin !== undefined) document.getElementById('leftMargin').value = settings.leftMargin;
                        if (settings.fontFamily) document.getElementById('fontFamily').value = settings.fontFamily;
                        if (settings.baseFontSize !== undefined) document.getElementById('baseFontSize').value = settings.baseFontSize;
                        if (settings.lineHeightMultiplier !== undefined) document.getElementById('lineHeightMultiplier').value = settings.lineHeightMultiplier;
                        if (settings.preserveBlankLines !== undefined) document.getElementById('preserveBlankLines').checked = settings.preserveBlankLines;
                        if (settings.enableIndent !== undefined) document.getElementById('enableIndent').checked = settings.enableIndent;
                        if (settings.bgColor) document.getElementById('bgColor').value = settings.bgColor;
                        if (settings.colorBefore) document.getElementById('colorBefore').value = settings.colorBefore;
                        if (settings.colorHighlight) document.getElementById('colorHighlight').value = settings.colorHighlight;
                        if (settings.colorAfter) document.getElementById('colorAfter').value = settings.colorAfter;
                        if (settings.cantoNumber !== undefined) document.getElementById('cantoNumber').value = settings.cantoNumber;
                        if (settings.chapterNumber !== undefined) document.getElementById('chapterNumber').value = settings.chapterNumber;
                        if (settings.cantoName !== undefined) document.getElementById('cantoName').value = settings.cantoName;
                        if (settings.chapterName !== undefined) document.getElementById('chapterName').value = settings.chapterName;
                    } catch (e) {
                        console.error('Error loading saved settings:', e);
                    }
                }
            }

            function parseAudacityLabels(labelText) {
                const lines = labelText.split('\n').filter(l => l.trim());
                const timestamps = [];

                for (const line of lines) {
                    const parts = line.trim().split(/\t/);
                    if (parts.length >= 2) {
                        const end = parseFloat(parts[1]);
                        if (!isNaN(end)) {
                            timestamps.push(end);
                        }
                    }
                }

                return timestamps;
            }

            function generateFfmpegConcat(timestamps) {
                const concatLines = [];

                for (let i = 0; i < timestamps.length; i++) {
                    const frameIndex = i;
                    concatLines.push(`file '${labelFileName}-Slide${String(frameIndex).padStart(4, '0')}.png'`);

                    let duration;
                    if (i === 0) {
                        duration = timestamps[i].toFixed(2);
                    } else {
                        duration = (timestamps[i] - timestamps[i - 1]).toFixed(2);
                    }

                    concatLines.push(`duration ${duration}`);

                    if (i + 1 == timestamps.length) {
                        concatLines.push(`file '${labelFileName}-Slide${String(frameIndex).padStart(4, '0')}.png'`);
                        concatLines.push(`duration ${duration}`);
                    }
                }

                return concatLines.join('\n');
            }

            function applyStanzaIndent(lines, enableIndent) {
                if (!enableIndent) return lines;

                const result = [];
                let i = 0;

                while (i < lines.length) {
                    const line1 = lines[i];
                    const isBlank1 = line1.trim().length === 0;

                    if (!isBlank1 && i + 4 < lines.length) {
                        const line2 = lines[i + 1];
                        const line3 = lines[i + 2];
                        const line4 = lines[i + 3];
                        const nextLine = lines[i + 4];

                        const isBlank2 = line2.trim().length === 0;
                        const isBlank3 = line3.trim().length === 0;
                        const isBlank4 = line4.trim().length === 0;
                        const nextIsBlank = nextLine.trim().length === 0;

                        if (!isBlank2 && !isBlank3 && !isBlank4 && nextIsBlank) {
                            result.push(line1);
                            result.push('    ' + line2);
                            result.push(line3);
                            result.push('    ' + line4);
                            result.push(nextLine);
                            i += 5;
                            continue;
                        }
                    }

                    result.push(line1);
                    i++;
                }

                return result;
            }

            async function loadFiles() {
                const file1 = document.getElementById('file1').files[0];
                const file2 = document.getElementById('file2').files[0];
                const bgImageFile = document.getElementById('bgImage').files[0];
                const labelFile = document.getElementById('labelFile').files[0];
                const enableIndent = document.getElementById('enableIndent').checked;
                const shouldPreserveBlankLines = document.getElementById('preserveBlankLines').checked;
                const skipLines = parseInt(document.getElementById('skipLines').value) || 0;
                const skipLastLines = parseInt(document.getElementById('skipLastLines').value) || 0;

                if (!file1) {
                    throw new Error('Please upload at least text file 1');
                }

                const text1 = await file1.text();
                let text2 = null;
                if (file2) {
                    text2 = await file2.text();
                }

                let lines1 = text1.split('\n');

                lastLine = lines1[lines1.length - 1];

                // Skip first N lines
                if (skipLines > 0) {
                    lines1 = lines1.slice(skipLines);
                }

                if (skipLastLines > 0) {
                    lines1 = lines1.slice(0, -skipLastLines);
                }

                lines1 = applyStanzaIndent(lines1, enableIndent);

                cachedLines1 = lines1.map(line => {
                    if (line.length > 0) return line;
                    return shouldPreserveBlankLines ? '' : null;
                }).filter(line => line !== null);

                if (text2) {
                    let lines2 = text2.split('\n');

                    // Skip first N lines from file 2 as well
                    if (skipLines > 0) {
                        lines2 = lines2.slice(skipLines);
                    }

                    if (skipLastLines > 0) {
                        lines2 = lines2.slice(0, -skipLastLines);
                    }

                    lines2 = applyStanzaIndent(lines2, enableIndent);
                    cachedLines2 = lines2.map(line => {
                        if (line.length > 0) return line;
                        return shouldPreserveBlankLines ? '' : null;
                    }).filter(line => line !== null);
                } else {
                    cachedLines2 = null;
                }

                const nonEmptyLines1 = cachedLines1.filter(l => l.trim().length > 0);

                if (nonEmptyLines1.length === 0) {
                    throw new Error('File 1 is empty');
                }

                if (cachedLines2) {
                    const nonEmptyLines2 = cachedLines2.filter(l => l.trim().length > 0);
                    if (nonEmptyLines2.length !== nonEmptyLines1.length) {
                        throw new Error(`Both files must have the same number of non-empty lines`);
                    }
                }

                if (labelFile) {
                    const labelText = await labelFile.text();
                    cachedLabelData = parseAudacityLabels(labelText);
                    if (cachedLabelData.length === 0) {
                        throw new Error('Label file is empty or invalid format');
                    }
                    // Extract filename without extension
                    labelFileName = labelFile.name.replace(/\.[^/.]+$/, "");
                } else {
                    cachedLabelData = null;
                    labelFileName = null;
                }

                if (bgImageFile) {
                    const bgImageUrl = URL.createObjectURL(bgImageFile);
                    cachedBgImage = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('Failed to load background image'));
                        img.src = bgImageUrl;
                    });
                }

                const startSlideFile = document.getElementById('startSlide').files[0];
                if (startSlideFile) {
                    const startSlideUrl = URL.createObjectURL(startSlideFile);
                    cachedStartSlide = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('Failed to load start slide'));
                        img.src = startSlideUrl;
                    });
                } else {
                    cachedStartSlide = null;
                }

                const endSlideFile = document.getElementById('endSlide').files[0];
                if (endSlideFile) {
                    const endSlideUrl = URL.createObjectURL(endSlideFile);
                    cachedEndSlide = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('Failed to load end slide'));
                        img.src = endSlideUrl;
                    });
                } else {
                    cachedEndSlide = null;
                }

                linesPerSlide = parseInt(document.getElementById('linesPerSlide').value) || 8;

                const nonEmptyCount = cachedLines1.filter(l => l.trim().length > 0).length;
                totalSlideGroups = Math.ceil(nonEmptyCount / linesPerSlide);
                currentPreviewSlideGroup = 0;
                currentPreviewHighlight = 0;

                // Load chapter metadata
                cantoNumber = document.getElementById('cantoNumber').value || '';
                chapterNumber = document.getElementById('chapterNumber').value || '';
                cantoName = document.getElementById('cantoName').value || '';
                chapterName = document.getElementById('chapterName').value || '';

                // Load chapter image
                const chapterImageFile = document.getElementById('chapterImage').files[0];
                if (chapterImageFile) {
                    const chapterImageUrl = URL.createObjectURL(chapterImageFile);
                    cachedChapterImage = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('Failed to load chapter image'));
                        img.src = chapterImageUrl;
                    });
                } else {
                    cachedChapterImage = null;
                }

                const profileImageFile = document.getElementById('profileImage').files[0];
                if (profileImageFile) {
                    const profileImageUrl = URL.createObjectURL(profileImageFile);
                    cachedProfileImage = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('Failed to load profile image'));
                        img.src = profileImageUrl;
                    });
                } else {
                    cachedProfileImage = null;
                }
            }

            function applyBackground(ctx, width, height, bgColor, bgImage) {
                if (bgImage) {
                    ctx.drawImage(bgImage, 0, 0, width, height);
                } else {
                    const bgType = document.getElementById('bgType')?.value || 'radial';

                    if (bgType === 'solid') {
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, width, height);
                    } else {
                        const color1 = document.getElementById('gradientColor1')?.value || '#1a1a2e';
                        const color2 = document.getElementById('gradientColor2')?.value || '#16213e';
                        let gradient;

                        if (bgType === 'linear-vertical') {
                            gradient = ctx.createLinearGradient(0, 0, 0, height);
                            gradient.addColorStop(0, color1);
                            gradient.addColorStop(1, color2);
                        } else if (bgType === 'linear-horizontal') {
                            gradient = ctx.createLinearGradient(0, 0, width, 0);
                            gradient.addColorStop(0, color1);
                            gradient.addColorStop(1, color2);
                        } else if (bgType === 'radial') {
                            gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, height);
                            gradient.addColorStop(0, color1);
                            gradient.addColorStop(1, color2);
                        }

                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, width, height);
                    }
                }
            }

            function createFirstSlide(firstLine, bgColor, fontFamily, bgImage) {
                const canvas = document.createElement('canvas');
                canvas.width = 1920;
                canvas.height = 1080;
                const ctx = canvas.getContext('2d');

                // Define rounded rectangle path
                const borderWidth = 3;
                const borderRadius = 30;
                const padding = 0;

                const x = padding + borderWidth / 2;
                const y = padding + borderWidth / 2;
                const width = 1920 - 2 * padding - borderWidth;
                const height = 1080 - 2 * padding - borderWidth;

                // Create the rounded rectangle path
                ctx.beginPath();
                ctx.moveTo(x + borderRadius, y);
                ctx.lineTo(x + width - borderRadius, y);
                ctx.arcTo(x + width, y, x + width, y + borderRadius, borderRadius);
                ctx.lineTo(x + width, y + height - borderRadius);
                ctx.arcTo(x + width, y + height, x + width - borderRadius, y + height, borderRadius);
                ctx.lineTo(x + borderRadius, y + height);
                ctx.arcTo(x, y + height, x, y + height - borderRadius, borderRadius);
                ctx.lineTo(x, y + borderRadius);
                ctx.arcTo(x, y, x + borderRadius, y, borderRadius);
                ctx.closePath();

                // Fill with gradient
                let gradient = ctx.createRadialGradient(960, 540, 0, 960, 540, 1080);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(1, '#6dd5fa');
                ctx.fillStyle = gradient;
                ctx.fill();

                // Stroke the border
                ctx.strokeStyle = 'cyan'; // Sky blue
                ctx.lineWidth = borderWidth;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();

                // Draw chapter image if available
                if (cachedChapterImage) {
                    const targetRatio = 1 / 1.15;
                    const imgX = 1000;
                    const imgY = 20;
                    const imgWidth = 900;
                    const imgHeight = imgWidth / targetRatio;

                    const sourceRatio = cachedChapterImage.width / cachedChapterImage.height;
                    let sourceX = 0, sourceY = 0;
                    let sourceWidth = cachedChapterImage.width;
                    let sourceHeight = cachedChapterImage.height;

                    if (sourceRatio > targetRatio) {
                        sourceWidth = cachedChapterImage.height * targetRatio;
                        sourceX = (cachedChapterImage.width - sourceWidth) / 2;
                    } else {
                        sourceHeight = cachedChapterImage.width / targetRatio;
                        sourceY = (cachedChapterImage.height - sourceHeight) / 2;
                    }

                    ctx.drawImage(cachedChapterImage, sourceX, sourceY, sourceWidth, sourceHeight, imgX, imgY, imgWidth, imgHeight);
                }

                // Draw text elements
                ctx.font = 'normal bold 80px Noto Sans Tamil';
                ctx.fillStyle = '#000080';
                ctx.textAlign = 'center';
                ctx.fillText('à®¸à¯à®°à¯€à®®à®¤à¯ à®ªà®¾à®•à®µà®¤à®®à¯', 483, 120);

                ctx.font = 'normal normal 60px Noto Sans Tamil';
                ctx.fillStyle = '#008000';
                ctx.textAlign = 'center';
                let text3 = '{cantoName}';
                text3 = text3.replace('{cantoName}', cantoName);
                ctx.fillText(text3, 494, 240);

                ctx.font = 'normal bold 60px Noto Sans Tamil';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                let text4 = '{chapterName}';
                text4 = text4.replace('{chapterName}', chapterName || firstLine);
                ctx.fillText(text4, 486, 360);

                ctx.font = 'normal bold 120px Noto Sans Tamil';
                ctx.fillStyle = '#000000';
                ctx.textAlign = 'center';
                let text2 = '{cantoNumber} - {chapterNumber}';
                text2 = text2.replace('{cantoNumber}', cantoNumber);
                text2 = text2.replace('{chapterNumber}', chapterNumber);
                ctx.fillText(text2, 486, 540);

                if (cachedProfileImage) {
                    const targetRatio = 1 / 1;
                    const imgX = 315;
                    const imgY = 630;
                    const imgWidth = 350;
                    const imgHeight = imgWidth / targetRatio; // This is 350

                    // --- Start of Circle Clipping Logic ---
                    const centerX = imgX + imgWidth / 2; // X-coordinate of the circle center
                    const centerY = imgY + imgHeight / 2; // Y-coordinate of the circle center
                    const radius = imgWidth / 2; // Radius of the circle (half the drawn width)

                    // 1. Begin a new path
                    ctx.beginPath();

                    // 2. Define the circular path
                    // The circle will be drawn centered within the destination rectangle
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);

                    // 3. Clip the canvas to this path
                    // All subsequent drawing operations will only affect the area inside this circle
                    ctx.clip();
                    // --- End of Circle Clipping Logic ---

                    const sourceRatio = cachedProfileImage.width / cachedProfileImage.height;
                    let sourceX = 0, sourceY = 0;
                    let sourceWidth = cachedProfileImage.width;
                    let sourceHeight = cachedProfileImage.height;

                    if (sourceRatio > targetRatio) {
                        sourceWidth = cachedProfileImage.height * targetRatio;
                        sourceX = (cachedProfileImage.width - sourceWidth) / 2;
                    } else {
                        sourceHeight = cachedProfileImage.width / targetRatio;
                        sourceY = (cachedProfileImage.height - sourceHeight) / 2;
                    }

                    // 4. Draw the image (it will automatically be clipped to the circle)
                    ctx.drawImage(cachedProfileImage, sourceX, sourceY, sourceWidth, sourceHeight, imgX, imgY, imgWidth, imgHeight);

                    // IMPORTANT: If you draw anything else after this that should NOT be clipped, 
                    // you may need to save the canvas state before the clip and restore it afterwards.
                    // ctx.save(); // place before ctx.clip()
                    // ctx.restore(); // place after ctx.drawImage()
                }

                return canvas;
            }

            function createLastSlide(lastLine, bgColor, fontFamily, bgImage) {
                const canvas = document.createElement('canvas');
                canvas.width = 1920;
                canvas.height = 1080;
                const ctx = canvas.getContext('2d');

                // Background
                let gradient;
                gradient = ctx.createRadialGradient(960, 540, 0, 960, 540, 1080);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(1, '#6dd5fa');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 1920, 1080);

                // Center the last line
                ctx.fillStyle = '#000000';
                ctx.textAlign = 'center';
                ctx.font = `bold 56px ${fontFamily}`;

                // Word wrap if needed
                const maxWidth = 1600;
                const words = lastLine.split(' ');
                const lines = [];
                let currentLine = '';

                for (let word of words) {
                    const testLine = currentLine + word + ' ';
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && currentLine !== '') {
                        lines.push(currentLine);
                        currentLine = word + ' ';
                    } else {
                        currentLine = testLine;
                    }
                }
                lines.push(currentLine);

                // Draw centered lines
                const lineHeight = 80;
                const totalHeight = lines.length * lineHeight;
                let yPos = (1080 - totalHeight) / 2 + 56;

                for (let line of lines) {
                    ctx.fillText(line.trim(), 960, yPos);
                    yPos += lineHeight;
                }

                return canvas;
            }

            function populateDropdowns() {
                const slideSelector = document.getElementById('slideSelector');
                const highlightSelector = document.getElementById('highlightSelector');

                slideSelector.innerHTML = '';
                highlightSelector.innerHTML = '';

                // Add "First Slide" option
                const firstOption = document.createElement('option');
                firstOption.value = -1;
                firstOption.textContent = 'First Slide';
                slideSelector.appendChild(firstOption);

                // Add regular slides
                for (let i = 0; i < totalSlideGroups; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `Slide ${i + 1} / ${totalSlideGroups}`;
                    slideSelector.appendChild(option);
                }

                // Add "Last Slide" option
                const lastOption = document.createElement('option');
                lastOption.value = -2;
                lastOption.textContent = 'Last Slide';
                slideSelector.appendChild(lastOption);

                // Populate highlight selector
                for (let i = 0; i < linesPerSlide; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${i + 1} / ${linesPerSlide}`;
                    highlightSelector.appendChild(option);
                }

                slideSelector.value = currentPreviewSlideGroup;
                highlightSelector.value = currentPreviewHighlight;
            }

            function jumpToSlide() {
                currentPreviewSlideGroup = parseInt(document.getElementById('slideSelector').value);
                updatePreview();
            }

            function jumpToHighlight() {
                currentPreviewHighlight = parseInt(document.getElementById('highlightSelector').value);
                updatePreview();
            }

            async function previewSlide() {
                const errorDiv = document.getElementById('error');
                const previewDiv = document.getElementById('preview');

                errorDiv.style.display = 'none';
                previewDiv.style.display = 'none';

                try {
                    await loadFiles();
                    currentPreviewSlideGroup = -1; // Start with first slide
                    currentPreviewHighlight = 0;
                    populateDropdowns();
                    updatePreview();
                    previewDiv.style.display = 'block';
                } catch (err) {
                    console.error('Error:', err);
                    errorDiv.textContent = 'âœ— Error: ' + err.message;
                    errorDiv.style.display = 'block';
                }
            }

            function updatePreview() {
                const bgColor = document.getElementById('bgColor').value || '#ffffff';
                const colorBefore = document.getElementById('colorBefore').value || '#999999';
                const colorHighlight = document.getElementById('colorHighlight').value || '#FFD700';
                const colorAfter = document.getElementById('colorAfter').value || '#000000';
                const fontFamily = document.getElementById('fontFamily').value || 'Arial';
                const baseFontSize = parseInt(document.getElementById('baseFontSize').value) || 60;
                const lineHeightMultiplier = parseFloat(document.getElementById('lineHeightMultiplier').value) || 1.4;
                const topMargin = parseInt(document.getElementById('topMargin').value) || 54;
                const leftMargin = parseInt(document.getElementById('leftMargin').value) || 54;

                const previewCanvas = document.getElementById('previewCanvas');
                const ctx = previewCanvas.getContext('2d');

                let canvas;

                // Check if showing first slide
                if (currentPreviewSlideGroup === -1) {
                    const nonEmptyLines1 = cachedLines1.filter(l => l.trim().length > 0);
                    const firstLine = nonEmptyLines1.length > 0 ? nonEmptyLines1[0] : '';

                    if (cachedStartSlide) {
                        canvas = document.createElement('canvas');
                        canvas.width = 1920;
                        canvas.height = 1080;
                        const tempCtx = canvas.getContext('2d');
                        tempCtx.drawImage(cachedStartSlide, 0, 0, 1920, 1080);
                    } else {
                        canvas = createFirstSlide(firstLine, bgColor, fontFamily, cachedBgImage);
                    }

                    // Disable highlight selector for first slide
                    document.getElementById('highlightSelector').disabled = true;
                }
                // Check if showing last slide
                else if (currentPreviewSlideGroup === -2) {
                    if (cachedEndSlide) {
                        canvas = document.createElement('canvas');
                        canvas.width = 1920;
                        canvas.height = 1080;
                        const tempCtx = canvas.getContext('2d');
                        tempCtx.drawImage(cachedEndSlide, 0, 0, 1920, 1080);
                    } else {
                        canvas = createLastSlide(lastLine, bgColor, fontFamily, cachedBgImage);
                    }

                    // Disable highlight selector for last slide
                    document.getElementById('highlightSelector').disabled = true;
                }
                // Regular content slides
                else {
                    // Enable highlight selector for content slides
                    document.getElementById('highlightSelector').disabled = false;

                    const nonEmptyLines1 = cachedLines1.filter(l => l.trim().length > 0);
                    const nonEmptyLines2 = cachedLines2 ? cachedLines2.filter(l => l.trim().length > 0) : null;

                    const startIdx = currentPreviewSlideGroup * linesPerSlide;
                    const endIdx = Math.min(startIdx + linesPerSlide, nonEmptyLines1.length);
                    const slideLines1 = nonEmptyLines1.slice(startIdx, endIdx);
                    const slideLines2 = nonEmptyLines2 ? nonEmptyLines2.slice(startIdx, endIdx) : null;
                    const isBilingual = !!cachedLines2;

                    canvas = createSlide(slideLines1, slideLines2, currentPreviewHighlight, isBilingual, bgColor, colorBefore, colorHighlight, colorAfter, fontFamily, baseFontSize, lineHeightMultiplier, cachedBgImage, topMargin, leftMargin);
                }

                ctx.drawImage(canvas, 0, 0);

                document.getElementById('slideSelector').value = currentPreviewSlideGroup;
                document.getElementById('highlightSelector').value = currentPreviewHighlight;
            }

            function nextSlide() {
                // If on first slide, go to first content slide
                if (currentPreviewSlideGroup === -1) {
                    currentPreviewSlideGroup = 0;
                    currentPreviewHighlight = 0;
                }
                // If on content slides
                else if (currentPreviewSlideGroup >= 0 && currentPreviewSlideGroup < totalSlideGroups) {
                    if (currentPreviewHighlight < linesPerSlide - 1) {
                        currentPreviewHighlight++;
                    } else if (currentPreviewSlideGroup < totalSlideGroups - 1) {
                        currentPreviewSlideGroup++;
                        currentPreviewHighlight = 0;
                    } else {
                        // Go to last slide
                        currentPreviewSlideGroup = -2;
                        currentPreviewHighlight = 0;
                    }
                }
                // Already on last slide, do nothing

                updatePreview();
            }

            function previousSlide() {
                // If on last slide, go to last content slide
                if (currentPreviewSlideGroup === -2) {
                    currentPreviewSlideGroup = totalSlideGroups - 1;
                    currentPreviewHighlight = linesPerSlide - 1;
                }
                // If on content slides
                else if (currentPreviewSlideGroup >= 0) {
                    if (currentPreviewHighlight > 0) {
                        currentPreviewHighlight--;
                    } else if (currentPreviewSlideGroup > 0) {
                        currentPreviewSlideGroup--;
                        currentPreviewHighlight = linesPerSlide - 1;
                    } else {
                        // Go to first slide
                        currentPreviewSlideGroup = -1;
                        currentPreviewHighlight = 0;
                    }
                }
                // Already on first slide, do nothing

                updatePreview();
            }

            async function generateSlideZip() {
                const errorDiv = document.getElementById('error');
                const successDiv = document.getElementById('success');
                const progressDiv = document.getElementById('progress');

                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';

                try {
                    await loadFiles();

                    progressDiv.style.display = 'block';

                    const bgColor = document.getElementById('bgColor').value || '#ffffff';
                    const colorBefore = document.getElementById('colorBefore').value || '#999999';
                    const colorHighlight = document.getElementById('colorHighlight').value || '#FFD700';
                    const colorAfter = document.getElementById('colorAfter').value || '#000000';
                    const fontFamily = document.getElementById('fontFamily').value || 'Arial';
                    const baseFontSize = parseInt(document.getElementById('baseFontSize').value) || 60;
                    const lineHeightMultiplier = parseFloat(document.getElementById('lineHeightMultiplier').value) || 1.4;
                    const topMargin = parseInt(document.getElementById('topMargin').value) || 54;
                    const leftMargin = parseInt(document.getElementById('leftMargin').value) || 54;

                    const zip = new JSZip();
                    let frameIndex = 0;

                    const nonEmptyLines1 = cachedLines1.filter(l => l.trim().length > 0);
                    const nonEmptyLines2 = cachedLines2 ? cachedLines2.filter(l => l.trim().length > 0) : null;

                    // Add custom start slide if provided
                    // Add custom start slide OR generated first slide
                    if (cachedStartSlide) {
                        const startCanvas = document.createElement('canvas');
                        startCanvas.width = 1920;
                        startCanvas.height = 1080;
                        const startCtx = startCanvas.getContext('2d');
                        startCtx.drawImage(cachedStartSlide, 0, 0, 1920, 1080);

                        const startBlob = await new Promise(resolve => startCanvas.toBlob(resolve, 'image/png', 0.95));
                        const startFilename = `${labelFileName}-Slide${String(frameIndex).padStart(4, '0')}.png`;
                        zip.file(startFilename, startBlob);
                        frameIndex++;
                    } else if (nonEmptyLines1.length > 0) {
                        // Generate first slide with metadata
                        const firstLine = nonEmptyLines1[0];
                        const firstSlideCanvas = createFirstSlide(firstLine, bgColor, fontFamily, cachedBgImage);
                        const firstSlideBlob = await new Promise(resolve => firstSlideCanvas.toBlob(resolve, 'image/png', 0.95));
                        const firstSlideFilename = `${labelFileName}-Slide${String(frameIndex).padStart(4, '0')}.png`;
                        zip.file(firstSlideFilename, firstSlideBlob);
                        frameIndex++;
                    }

                    const nonEmptyCount = nonEmptyLines1.length;
                    const totalGroups = Math.ceil(nonEmptyCount / linesPerSlide);

                    for (let slideIdx = 0; slideIdx < totalGroups; slideIdx++) {
                        const startIdx = slideIdx * linesPerSlide;
                        const endIdx = Math.min(startIdx + linesPerSlide, nonEmptyCount);
                        const slideLines1 = nonEmptyLines1.slice(startIdx, endIdx);
                        const slideLines2 = nonEmptyLines2 ? nonEmptyLines2.slice(startIdx, endIdx) : null;
                        const isBilingual = !!cachedLines2;

                        const actualLinesInThisSlide = slideLines1.length;

                        for (let highlightIdx = 0; highlightIdx < actualLinesInThisSlide; highlightIdx++) {
                            const canvas = createSlide(slideLines1, slideLines2, highlightIdx, isBilingual, bgColor, colorBefore, colorHighlight, colorAfter, fontFamily, baseFontSize, lineHeightMultiplier, cachedBgImage, topMargin, leftMargin);

                            const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 0.95));
                            const filename = `${labelFileName}-Slide${String(frameIndex).padStart(4, '0')}.png`;
                            zip.file(filename, blob);
                            frameIndex++;

                            const progress = Math.round((slideIdx * linesPerSlide + highlightIdx + 1) / (totalGroups * linesPerSlide) * 100);
                            document.getElementById('progressFill').textContent = progress + '%';
                            document.getElementById('progressFill').style.width = progress + '%';
                        }
                    }

                    // Add custom end slide if provided
                    // Add custom end slide OR generated last slide
                    if (cachedEndSlide) {
                        const endCanvas = document.createElement('canvas');
                        endCanvas.width = 1920;
                        endCanvas.height = 1080;
                        const endCtx = endCanvas.getContext('2d');
                        endCtx.drawImage(cachedEndSlide, 0, 0, 1920, 1080);

                        const endBlob = await new Promise(resolve => endCanvas.toBlob(resolve, 'image/png', 0.95));
                        const endFilename = `${labelFileName}-Slide${String(frameIndex).padStart(4, '0')}.png`;
                        zip.file(endFilename, endBlob);
                        frameIndex++;
                    } else if (nonEmptyLines1.length > 0) {
                        // Generate last slide with last line
                        const lastSlideCanvas = createLastSlide(lastLine, bgColor, fontFamily, cachedBgImage);
                        const lastSlideBlob = await new Promise(resolve => lastSlideCanvas.toBlob(resolve, 'image/png', 0.95));
                        const lastSlideFilename = `${labelFileName}-Slide${String(frameIndex).padStart(4, '0')}.png`;
                        zip.file(lastSlideFilename, lastSlideBlob);
                        frameIndex++;
                    }

                    if (cachedLabelData && cachedLabelData.length > 0) {
                        const concatContent = generateFfmpegConcat(cachedLabelData);
                        zip.file('concat.txt', concatContent);

                        const wavFileName = `/Volumes/samsung/bhagavatham/audio/${labelFileName.replace('SB-', '')}.wav`
                        const pythonScript = `#!/usr/bin/env python3
import subprocess
import os
import sys

def main():
    if len(sys.argv) > 1:
        wav_file = sys.argv[1]
    else:
        wav_file = input("Enter the WAV file full path (${wavFileName}): ").strip()
        if wav_file == "":
            wav_file = "${wavFileName}"
    
    if not os.path.exists(wav_file):
        print(f"Error: WAV file '{wav_file}' not found")
        sys.exit(1)
    
    if not os.path.exists('concat.txt'):
        print("Error: concat.txt not found in current directory")
        sys.exit(1)
    
    cmd = [
        'ffmpeg',
        '-f', 'concat',
        '-safe', '0',
        '-i', 'concat.txt',
        '-i', wav_file,
        '-c:v', 'libx264',
        '-tune', 'stillimage',
        '-c:a', 'aac',
        '-b:a', '192k',
        '-pix_fmt', 'yuv420p',
        '-shortest',
        '-y',
        '${labelFileName}.mp4'
    ]
    
    print(f"Running command: {' '.join(cmd)}")
    print("This may take a while...")
    
    try:
        subprocess.run(cmd, check=True)
        print("âœ“ MP4 generated successfully as ${labelFileName}.mp4")
    except subprocess.CalledProcessError as e:
        print(f"âœ— Error: ffmpeg command failed with exit code {e.returncode}")
        sys.exit(1)
    except FileNotFoundError:
        print("âœ— Error: ffmpeg not found. Please install ffmpeg and add it to PATH")
        sys.exit(1)

if __name__ == '__main__':
    main()
`;
                        zip.file('generate_mp4.py', pythonScript);
                    }

                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    const zipFileName = labelFileName ? `${labelFileName}.zip` : 'slides.zip';
                    downloadBlob(zipBlob, zipFileName);

                    document.getElementById('progressFill').textContent = '100%';
                    document.getElementById('progressFill').style.width = '100%';

                    const concatMsg = cachedLabelData ? ' + concat.txt' : '';
                    successDiv.textContent = `âœ“ Generated ${frameIndex} slide images${concatMsg} as ${zipFileName}!`;
                    successDiv.style.display = 'block';
                    progressDiv.style.display = 'none';

                } catch (err) {
                    console.error('Error:', err);
                    errorDiv.textContent = 'âœ— Error: ' + err.message;
                    errorDiv.style.display = 'block';
                    progressDiv.style.display = 'none';
                }
            }

            function createSlide(lines1, lines2, highlightIdx, isBilingual, bgColor, colorBefore, colorHighlight, colorAfter, fontFamily, baseFontSize, lineHeightMultiplier, bgImage, topMargin, leftMargin) {
                const canvas = document.createElement('canvas');
                canvas.width = 1920;
                canvas.height = 1080;
                const ctx = canvas.getContext('2d');

                if (bgImage) {
                    ctx.drawImage(bgImage, 0, 0, 1920, 1080);
                } else {
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, 1920, 1080);
                }

                const totalLines = lines1.length;
                const availableHeight = 1080 - (2 * topMargin);

                let fontSize = baseFontSize;
                let lineHeight = fontSize * lineHeightMultiplier;
                let requiredHeight = totalLines * lineHeight;
                if (requiredHeight > availableHeight) {
                    const scaleFactor = availableHeight / requiredHeight;
                    fontSize = Math.max(12, fontSize * scaleFactor);
                    lineHeight = fontSize * lineHeightMultiplier;
                }

                ctx.font = `bold ${fontSize}px ${fontFamily}`;
                ctx.textAlign = 'left';

                const startY = topMargin + fontSize;

                if (isBilingual) {
                    const halfHeight = 540;
                    let yPos1 = startY;
                    let yPos2 = startY;

                    for (let i = 0; i < lines1.length; i++) {
                        if (i < highlightIdx) {
                            ctx.fillStyle = colorBefore;
                        } else if (i === highlightIdx) {
                            ctx.fillStyle = colorHighlight;
                        } else {
                            ctx.fillStyle = colorAfter;
                        }

                        ctx.fillText(lines1[i], leftMargin, yPos1);
                        ctx.fillText(lines2[i], leftMargin, halfHeight + yPos2);

                        yPos1 += lineHeight;
                        yPos2 += lineHeight;
                    }
                } else {
                    for (let i = 0; i < lines1.length; i++) {
                        if (i < highlightIdx) {
                            ctx.fillStyle = colorBefore;
                        } else if (i === highlightIdx) {
                            ctx.fillStyle = colorHighlight;
                        } else {
                            ctx.fillStyle = colorAfter;
                        }

                        ctx.fillText(lines1[i], leftMargin, startY + i * lineHeight);
                    }
                }

                return canvas;
            }

            function downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function createFileList(files) {
                const dataTransfer = new DataTransfer();
                files.forEach(file => dataTransfer.items.add(file));
                return dataTransfer.files;
            }

            async function loadFileFromUrl(fileUrl) {
                try {
                    let url = fileUrl;
                    if (fileUrl.startsWith('file:///')) {
                        const filePath = fileUrl.replace('file://', '');
                        url = filePath;
                    }

                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Failed to load file: ${response.status} ${response.statusText}. URL: ${url}`);
                    }
                    const blob = await response.blob();
                    const filename = url.split('/').pop() || 'file';
                    const file = new File([blob], filename, { type: blob.type });
                    return file;
                } catch (error) {
                    throw new Error(`Cannot load file from URL: ${error.message}`);
                }
            }

            window.addEventListener('DOMContentLoaded', async function () {
                await loadWebFonts();

                loadSavedSettings();

                // Load default profile image
                try {
                    const response = await fetch('images/profileW.png');
                    const blob = await response.blob();
                    const file = new File([blob], 'profileW.png', { type: blob.type });
                    document.getElementById('profileImage').files = createFileList([file]);
                } catch (error) {
                    console.log('Default profile image not found, skipping');
                }

                const inputs = ['skipLines', 'skipLastLines', 'linesPerSlide', 'topMargin', 'leftMargin', 'fontFamily',
                    'baseFontSize', 'lineHeightMultiplier', 'preserveBlankLines', 'enableIndent',
                    'bgColor', 'colorBefore', 'colorHighlight', 'colorAfter', 'cantoNumber', 'chapterNumber', 'cantoName', 'chapterName'];
                inputs.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('change', saveSettings);
                    }
                });
            });

            window.slideGeneratorAPI = {
                setFile1: function (file) {
                    document.getElementById('file1').files = createFileList([file]);
                    console.log('âœ“ File 1 set');
                },
                setFile2: function (file) {
                    document.getElementById('file2').files = createFileList([file]);
                    console.log('âœ“ File 2 set');
                },
                setLabelFile: function (file) {
                    document.getElementById('labelFile').files = createFileList([file]);
                    console.log('âœ“ Label file set');
                },
                setBgImage: function (file) {
                    document.getElementById('bgImage').files = createFileList([file]);
                    console.log('âœ“ Background image set');
                },
                setFile1Url: async function (fileUrl) {
                    try {
                        const file = await loadFileFromUrl(fileUrl);
                        this.setFile1(file);
                    } catch (error) {
                        console.error('âœ— Error loading File 1:', error.message);
                    }
                },
                setFile2Url: async function (fileUrl) {
                    try {
                        const file = await loadFileFromUrl(fileUrl);
                        this.setFile2(file);
                    } catch (error) {
                        console.error('âœ— Error loading File 2:', error.message);
                    }
                },
                setLabelFileUrl: async function (fileUrl) {
                    try {
                        const file = await loadFileFromUrl(fileUrl);
                        this.setLabelFile(file);
                    } catch (error) {
                        console.error('âœ— Error loading Label file:', error.message);
                    }
                },
                setBgImageUrl: async function (fileUrl) {
                    try {
                        const file = await loadFileFromUrl(fileUrl);
                        this.setBgImage(file);
                    } catch (error) {
                        console.error('âœ— Error loading Background image:', error.message);
                    }
                },
                setStartSlide: function (file) {
                    document.getElementById('startSlide').files = createFileList([file]);
                    console.log('âœ“ Start slide set');
                },
                setEndSlide: function (file) {
                    document.getElementById('endSlide').files = createFileList([file]);
                    console.log('âœ“ End slide set');
                },
                setStartSlideUrl: async function (fileUrl) {
                    try {
                        const file = await loadFileFromUrl(fileUrl);
                        this.setStartSlide(file);
                    } catch (error) {
                        console.error('âœ— Error loading Start slide:', error.message);
                    }
                },
                setEndSlideUrl: async function (fileUrl) {
                    try {
                        const file = await loadFileFromUrl(fileUrl);
                        this.setEndSlide(file);
                    } catch (error) {
                        console.error('âœ— Error loading End slide:', error.message);
                    }
                },
                setSkipLines: function (value) {
                    document.getElementById('skipLines').value = value;
                    console.log('âœ“ Skip lines set to ' + value);
                },
                setSkipLastLines: function (value) {
                    document.getElementById('skipLastLines').value = value;
                    console.log('âœ“ Skip last lines set to ' + value);
                },
                setLinesPerSlide: function (value) {
                    document.getElementById('linesPerSlide').value = value;
                    console.log('âœ“ Lines per slide set to ' + value);
                },
                setTopMargin: function (value) {
                    document.getElementById('topMargin').value = value;
                    console.log('âœ“ Top margin set to ' + value);
                },
                setLeftMargin: function (value) {
                    document.getElementById('leftMargin').value = value;
                    console.log('âœ“ Left margin set to ' + value);
                },
                setFontFamily: function (value) {
                    document.getElementById('fontFamily').value = value;
                    console.log('âœ“ Font family set to ' + value);
                },
                setBaseFontSize: function (value) {
                    document.getElementById('baseFontSize').value = value;
                    console.log('âœ“ Base font size set to ' + value);
                },
                setLineHeightMultiplier: function (value) {
                    document.getElementById('lineHeightMultiplier').value = value;
                    console.log('âœ“ Line height multiplier set to ' + value);
                },
                setBgColor: function (color) {
                    document.getElementById('bgColor').value = color;
                    console.log('âœ“ Background color set to ' + color);
                },
                setColorBefore: function (color) {
                    document.getElementById('colorBefore').value = color;
                    console.log('âœ“ Before color set to ' + color);
                },
                setColorHighlight: function (color) {
                    document.getElementById('colorHighlight').value = color;
                    console.log('âœ“ Highlight color set to ' + color);
                },
                setColorAfter: function (color) {
                    document.getElementById('colorAfter').value = color;
                    console.log('âœ“ After color set to ' + color);
                },
                enableIndent: function (enabled) {
                    document.getElementById('enableIndent').checked = enabled;
                    console.log('âœ“ Indent ' + (enabled ? 'enabled' : 'disabled'));
                },
                setPreserveBlankLines: function (enabled) {
                    document.getElementById('preserveBlankLines').checked = enabled;
                    console.log('âœ“ Preserve blank lines ' + (enabled ? 'enabled' : 'disabled'));
                },
                setCantoNumber: function (value) {
                    document.getElementById('cantoNumber').value = value;
                    console.log('âœ“ Canto Number set to ' + value);
                },
                setChapterNumber: function (value) {
                    document.getElementById('chapterNumber').value = value;
                    console.log('âœ“ Chapter Number set to ' + value);
                },
                setCantoName: function (value) {
                    document.getElementById('cantoName').value = value;
                    console.log('âœ“ Canto Name set to ' + value);
                },
                setChatperName: function (value) {
                    document.getElementById('chapterName').value = value;
                    console.log('âœ“ Chapter Name set to ' + value);
                },

                preview: function () {
                    previewSlide();
                    console.log('âœ“ Preview started');
                },
                generate: function () {
                    generateSlideZip();
                    console.log('âœ“ Generation started');
                },
                applySettings: function (config) {
                    if (config.skipLines !== undefined) this.setSkipLines(config.skipLines);
                    if (config.skipLastLines !== undefined) this.setSkipLines(config.skipLastLines);
                    if (config.linesPerSlide) this.setLinesPerSlide(config.linesPerSlide);
                    if (config.topMargin !== undefined) this.setTopMargin(config.topMargin);
                    if (config.leftMargin !== undefined) this.setLeftMargin(config.leftMargin);
                    if (config.fontFamily) this.setFontFamily(config.fontFamily);
                    if (config.baseFontSize) this.setBaseFontSize(config.baseFontSize);
                    if (config.lineHeightMultiplier) this.setLineHeightMultiplier(config.lineHeightMultiplier);
                    if (config.bgColor) this.setBgColor(config.bgColor);
                    if (config.colorBefore) this.setColorBefore(config.colorBefore);
                    if (config.colorHighlight) this.setColorHighlight(config.colorHighlight);
                    if (config.colorAfter) this.setColorAfter(config.colorAfter);
                    if (config.enableIndent !== undefined) this.enableIndent(config.enableIndent);
                    if (config.preserveBlankLines !== undefined) this.setPreserveBlankLines(config.preserveBlankLines);
                    console.log('âœ“ All settings applied');
                },
                setAll: function (config) {
                    if (config.file1) this.setFile1(config.file1);
                    if (config.file2) this.setFile2(config.file2);
                    if (config.labelFile) this.setLabelFile(config.labelFile);
                    if (config.bgImage) this.setBgImage(config.bgImage);
                    if (config.startSlide) this.setStartSlide(config.startSlide);
                    if (config.endSlide) this.setEndSlide(config.endSlide);
                    this.applySettings(config);
                },
                setAllUrl: async function (config) {
                    if (config.file1Url) await this.setFile1Url(config.file1Url);
                    if (config.file2Url) await this.setFile2Url(config.file2Url);
                    if (config.labelFileUrl) await this.setLabelFileUrl(config.labelFileUrl);
                    if (config.bgImageUrl) await this.setBgImageUrl(config.bgImageUrl);
                    if (config.startSlideUrl) await this.setStartSlideUrl(config.startSlideUrl);
                    if (config.endSlideUrl) await this.setEndSlideUrl(config.endSlideUrl);
                    this.applySettings(config);
                }
            };
        </script>
</body>

</html>

<!--

Individual setters:

slideGeneratorAPI.setFile1(fileObject);
slideGeneratorAPI.setLinesPerSlide(8);
slideGeneratorAPI.setFontFamily('Arial');
slideGeneratorAPI.setBgColor('#ffffff');
slideGeneratorAPI.setColorHighlight('#FFD700');
slideGeneratorAPI.setFPS(30);
slideGeneratorAPI.generate();

// Preview slide 5
slideGeneratorAPI.preview(5);

Or use setAll() for everything at once:

slideGeneratorAPI.setAll({
    file1: file1Obj,
    labelFile: labelFileObj,
    wavFile: wavFileObj,
    linesPerSlide: 8,
    copiesPerSlide: 3,
    fontFamily: 'Arial',
    baseFontSize: 60,
    lineHeightMultiplier: 1.4,
    bgColor: '#ffffff',
    colorBefore: '#999999',
    colorHighlight: '#FFD700',
    colorAfter: '#000000',
    fps: 30
});
slideGeneratorAPI.generate();

Available methods:

setFile1(file) - Set text file 1
setFile2(file) - Set text file 2
setLabelFile(file) - Set Audacity label file
setWavFile(file) - Set WAV audio file
setBgImage(file) - Set background image
setLinesPerSlide(value)
setCopiesPerSlide(value)
setFontFamily(value)
setBaseFontSize(value)
setLineHeightMultiplier(value)
setBgColor(color) - hex color like '#ffffff'
setColorBefore(color) - hex color for before lines
setColorHighlight(color) - hex color for highlighted line
setColorAfter(color) - hex color for after lines
setFPS(value)
generate() - Start video generation
setAll(config) - Set all parameters at once

Now you can fully automate the process from the console!
-->